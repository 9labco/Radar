<!DOCTYPE HTML>
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
	<title>Make a Radar with Arduino + Node.js + Raphael</title>
	
	<link rel="stylesheet" href="css/style.css" />
</head>
<body>
	<div id="main">
		<div id="canvas"></div>
	</div>
	<script type="text/javascript" src="js/jquery-1.7.2.min.js"></script>
	<script type="text/javascript" src="js/math.js"></script>
	<script type="text/javascript" src="js/raphael-min.js"></script>
	<script type="text/javascript" src="js/stats.js"></script>
	<script type="text/javascript">
		!(function() {

			// Stats.js _______________________________________________

			var stats = new Stats();

			stats.domElement.style.position = 'absolute';
			stats.domElement.style.left = '0px';
			stats.domElement.style.top = '0px';
			document.body.appendChild( stats.domElement );

			// Initalize ___________________________________________
			
			var minAngle = -90;
			var maxAngle = 90;
			var pos = []; // Radar positions
			var high = 0; // Highest position
			var drawPath = "";
			var detectAngle = 15;
			var centerP = {x:400, y:300}; // Center points
			var paper = Raphael("canvas", 800, 600);
			var duration = 700;
			var curve;
			var circle = paper.circle(centerP.x, centerP.y, 200).attr({ fill: "#fbb03b", "stroke-width": 0, opacity: 0.2 });
			var area1 = paper.circle(centerP.x, centerP.y, 100).attr({ fill: "#fbb03b", "stroke-width": 0, opacity: 0.2 });
			var area2 = paper.circle(centerP.x, centerP.y, 32).attr({ fill: "#fbb03b", "stroke-width": 0, opacity: 0.2 });
			var radar = paper.path("M" + centerP.x + "," + centerP.y + " v-200 a200,200 0 0,0 -200,200 z")
				.attr({
					"fill": "225-#fbb03b:20-#fbb03b:50",
					"fill-opacity": "0.01",
					"stroke": ""
				})
				.transform("r-180,400,300");
			
			// Logic _______________________________________________
			
			function getPointAt(center, radius, angle) {
				angle *= Math.PI / 180;
				return {x: center.x + Math.sin(Math.PI - angle) * radius,
						y: center.y + Math.cos(Math.PI - angle) * radius};
			}

			function draw(distance, angle) {
				
				var lastPos;
				
				high = (distance > high)?distance:high;
				pos.push(distance);

				for(var i = 0; i < pos.length; i++) {
					var d, p, path;
					
					p = (pos[i])?((pos[i] / high) * 200):0;
					a = (i * 15) - 90;
					d = getPointAt(centerP, p, a - (detectAngle/2));
					d2 = getPointAt(centerP, p, a + (detectAngle/2));
					
					if(i == 0) {
						drawPath = "M" + d.x + " " + d.y + "l" + (d2.x - d.x) + " " + (d2.y - d.y);
					} else {
						var nx = (d.x - lastPos.x);
						var ny = (d.y - lastPos.y);
						drawPath += "l" + nx + " " + ny  + "l" + (d2.x - d.x) + " " + (d2.y - d.y);
					}
					
					lastPos = {x: d2.x, y: d2.y};
				}

				if(curve == null) {
					curve = paper.path(drawPath.substr(0, drawPath.indexOf("l"))).attr({
						"stroke-width": 4,
						"stroke": "#fbb03b"
					});
				}

				// Radar animation
				var a = Math.map(angle, minAngle, maxAngle, minAngle - (detectAngle / 2), maxAngle + (detectAngle / 2));
				radar.animate({transform: "r" + a + "," + centerP.x + "," + centerP.y + "}"}, duration, function() {
					curve.animate({path: drawPath}, duration);
				});
				
				if(angle >= maxAngle) {
					curve.animate({path: drawPath}, duration, function() {
						this.animate({opacity: 0}, duration * 2, function() {
							this.remove();
						});
					});
					radar.animate({transform: "r180," + centerP.x + "," + centerP.y + "}"}, duration, function() {
						this.attr({transform: "r-180," + centerP.x + "," + centerP.y + "}"});
					});
					curve = null;
					angle = minAngle;
					drawPath = "";
					high = 0;
					pos = [];
				}
				
				stats.update();
			}
			
			var angle = minAngle;
			
			function loop() {
				setTimeout(function() {
					var d, r;
					
					if(angle > maxAngle) {
						angle = minAngle;
					}
					
					d = ~~(Math.random() * 50) + 50;
					//d = 50;
					r = angle;
					draw(d, r);
					angle += 15;
					loop();
				}, 750);
			}
			
			loop();

		})();
	</script>
</body>
</html>
